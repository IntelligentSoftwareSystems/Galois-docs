/**

\page Manual Manual
@section allocator Allocators

Allocators are used by dynamic data structures whose size is either known at
runtime or changes during execution, e.g., std::vector, std::set, etc. 
The default allocators in C/C++ often use a single lock on their internal heap,
and, therefore, do not scale with multiple threads. Similarly, \b malloc and \b
free, do not scale with multiple threads. As a result, parallel code that uses the
default C/C++ allocators does not scale beyond a few threads. In Galois, we have designed scalable
parallel allocators for some of the common usage patterns. We describe some of them
below:

\subsection per-iter-alloc Per Iteration Allocator
Per Iteration Allocator {@link Galois::PerIterAllocTy} can be used when dynamic data structures are defined inside
the parallel loop and live for only one iteration of the loop. This allocator can
be used inside the functors for Galois::for_each and Galois::do_all. It can be used
with STL data structures, e.g., std::vector and std::set etc., and, supports
variable size allocations. 

We will use Delaunay Mesh Refinement (DMR), as an example to illustrate the use of the Per Iteration
Allocator. The following steps are required to access the Per Iteration Allocator:

- The loop operator (functor) needs specify the \t tt_needs_per_iter_alloc
  flag, as a \b typedef, to enable the allocator. E.g., in DMR 
  {@link apps/delaunayrefinement/DelaunayRefinement.cpp}: 
  @snippet apps/delaunayrefinement/DelaunayRefinement.cpp Enabling Per Iteration Allocator in DMR

- A reference to the allocator can be accessed through 
  {@link Galois::UserContext::getPerIterAlloc}. E.g., in DMR
  {@link apps/delaunayrefinement/DelaunayRefinement.cpp}:
  @snippet apps/delaunayrefinement/DelaunayRefinement.cpp  Accessing Per Iteration Allocator in DMR

- \b TODO: Typedef using per-iter-alloc
- \b TODO: Passing per-iter-alloc to STL vector
  
\subsection fixed-size-alloc Fixed Size Allocator

A common usage pattern is to allocate objects of the same type inside the parallel
loop. Such an allocator can be implemented easily in a scalable manner. Galois
provides {@link Galois::GFixedAllocator}, which takes a template parameter as the
type of object to be allocated. It only supports allocating objects of one specific type
(and size), therefore, it cannot be used with STL data structures like std::vector
and std::deque, which allocate variable size chunks. However, it can be used with
STL data structures like std::set, and std::list, etc., which allocated objects of
one type only. The source for {@link Galois::ThreadSafeOrderedSet} shows how
a fixed size allocator can be passed to std::set.

This allocator is typically instantiated outside the parallel loop by the master
thread and then can be used by multiple parallel loops.  An example from {@link
include/Galois/gdeque.h} is shown below:

@snippet include/Galois/gdeque.h Example Fixed Size Allocator


\subsection var-size-alloc Variable Size Allocator
\b TBD

\subsection plugin-other-alloc Plugging in 3rd Party Allocators

{@link Galois::Runtime::MM::ExternRefGaloisAllocator} is a wrapper class that can
be used to wrap any third-party heap implementation, and make it use-able by Galois
and STL data structures. It takes the type-name of the heap implementation as a
template parameter and a reference to it for instantiating the allocator object.  

Following is an example of how \b malloc and \b free, from C, can be wrapped into
an allocator using this class, (see file {@link include/Galois/Runtime/mm/Mem.h}):
@snippet include/Galois/Runtime/mm/Mem.h Example Third Party Allocator


\b TODO: show snippet using MallocHeap

\subsection build-custom-alloc Types of Heaps and Building Custom Allocators

- 

*/

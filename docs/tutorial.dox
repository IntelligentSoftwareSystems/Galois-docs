/**
\page tutorial Tutorial

\tableofcontents


@section goal_tutorial Goal of This Tutorial

This tutorial is targeted to people who want to start writing Galois programs, which are legal C++ parallel programs. It assumes that readers are familiar with C++ and have some knowledge about parallel programming.

The following topics are outside the scope of this tutorial:
<ol>
<li> Performance programming in Galois, such as optimizing for non-uniform memory access (NUMA). However, there will be some discussion on this at the end of this tutorial.
<li> Extending Galois such as implementing new parallel data structures, schedulers or parallelism patterns.
</ol>


@section execution_model Execution Model

A Galois program alternates its execution in between serial and parallel phases. The execution begins serially with master thread, whose thread ID is 0. Other threads wait in a "sleep" state in galois::substrate::ThreadPool, which is created by galois::SharedMemSys. Upon encountering a parallel section, Galois runtime wakes up threads in cascade, and hand threads a work function. Threads meet at a barrier by the end of the parallel section. In current implementation, parallel sections are loops and work items are iterations of that loop.

Galois is different from other models in the following two ways.
<ol>
<li> Parallel work may or may not be independent; implementation guarantees transactional execution of each work item (iteration).
<li> Parallel sections may create and execute new work items. This intuitively follows data-driven algorithms, in which active work items are tracked and may be created on the fly. This feature is important for high-diameter graphs like circuits.
</ol>


@section galois_program Galois Programs

A Galois user program consists of operators, schedules and data structure API calls. Galois runtime system implements schedulers and data structures, which are built upon thread primitives and memory allocators. If the Galois runtime system is geared toward shared-memory platforms, then the Galois program executes on multi-cores. This is summarized as the following figure.

@image html galois_program_structure.png "Structure of a Galois Program"

Through out this tutorial, we will use the following application as our running example: Read in an undirected graph with edge weights, and then set node label to the sum of weights on edges connected to node. There are two ways to implement this application. If it is implemented as a pull-style algorithm, each node iterates over its edges and compute its label; there are no conflicts among activities at different nodes. However, when it is implemented as a push-style algorithm, each node iterates over its edges and for each edge, the node updates weight of destination node. Therefore, activities may conflict with each other. Both variants iterate over all nodes, so they are topology-driven algorithms.

Below we will cover parallel data structures, parallel loop iterators, and worklists and schedules.

@section galois_lc_graphs Parallel Data Structures

For graph computation, Galois provides unified, standard APIs to access graph elements and a set of graph implementations optimized for NUMA-awareness, conflict detection and interoperability with Galois runtime system. All graphs are in the namespace galois::graphs. There are two types of graphs:
<ol>
<li> galois::graphs::FirstGraph: It allows insertion and removal of nodes and edges. It is used in morph algorithms like delaunay mesh refinement. galois::graphs::LC_Morph_Graph can be used if (1) only insertions of nodes and edges are possible, and (2) when a node is created, its maximum degree is known.
<li> galois::graphs::LC_CSR_Graph: It disallows creation and removal of nodes and edges. Internally, it is implemented with compressed sparse row format, as shown in the following figure. Undirected edges are represented as two directed edges. Galois also provides variants of this graph with different storage representations, e.g. galois::graphs::LC_InlineEdge_Graph, galois::graphs::LC_Linear_Graph, galois::graphs::LC_InOut_Graph.
</ol>

@image html csr_format_example Graph in CSR Format

Other data structures available in Galois are galois::InsertBag, Trees and reducers. We will focus on galois::graphs::LC_CSR_Graph in this section.

When defining a galois::graphs::LC_CSR_Graph, you must provide as template paratemers NodeTy, the type of data stored on each node; and EdgeTy, the type of data stored on each edge. Use void when no data needs to be stored on nodes or edges. See galois::graphs::LC_CSR_Graph for other optional template parameters.

Below is an example of defining a LC_CSR_Graph with integer as its node data type and edge data type:

@snippet lonestar/tutorial_examples/GraphTraversalSerial.cpp Define LC_CSR_Graph

The following code snippet shows how to instantiate and read in a graph from a file (in binary gr format):

@snippet lonestar/tutorial_examples/GraphTraversalSerial.cpp Read a graph

To access graph elements, use the following constructs.
<ol>
<li> The nodes can be accessed by the node iterator galois::graphs::LC_CSR_Graph::iterator with galois::graphs::LC_CSR_Graph::begin and galois::graphs::LC_CSR_Graph::end.
<li> The outgoing edges of a node can be accessed by the edge iterator galois::graphs::LC_CSR_Graph::edge_iterator with galois::graphs::LC_CSR_Graph::edge_begin and galois::graphs::LC_CSR_Graph::edge_end.
<li> To read/write a node data, use galois::graphs::LC_CSR_Graph::getData.
<li> To read/write an edge data, use galois::graphs::LC_CSR_Graph::getEdgeData.
<li> To access the destination node of an outgoing edge, use galois::graphs::LC_CSR_Graph::getEdgeDst.
</ol>

The following example is a serial implementation of our running example. It is a pull-style implementation: Iterate through all nodes, and for each node, add all outgoing edges' weights to the node data. This example is written in C++11 to avoid mentioning node ietrators and edge iterators explicitly.

@snippet lonestar/tutorial_examples/GraphTraversalSerial.cpp Graph traversal

The full example is available as {@link lonestar/tutorial_examples/GraphTraversalSerial.cpp}


@section galois_parallel_loop Parallel Loop Iterators


@subsection galois_do_all galois::do_all

galois::do_all partitions the work items evenly among threads, and each thread performs works independently. It turns off conflict detection and assumes no new work items are created. Work stealing can be turned on to achieve load balance among threads. Example usages of galois::do_all are topology-driven algorithms iterating over nodes in a graph; and bags with independent work items, e.g. subset of nodes in a graph.

Specifically, galois::do_all expects the following inputs:
<ol>
<li> Range as galois::iterate, which takes one of the following parameter:
  <ul>
  <li> Pair of iterators for begin() and end()
  <li> Pair of unsigned integers for begin and end
  <li> Initializer list
  <li> Container inside which a well-defined iterator is implemented
  </ul>
<li> Operator, which can be specified as lambda expression, function object (functor) or function pointer. Using lambda expression is recommended.
<li> Options to turn on/off some features.
  <ul>
  <li> galois::steal to turn on work stealing
  <li> galois::chunk_size for the unit of work stealing. Chunk size is 32 by default.
  <li> galois::loopname to turn on the collection of statistics associated with the do_all loop, e.g. execution time in milliseconds, number of iterations done.
  </ul>
</ol>

Below is the example of paralleizing our running example in pull-style operator using galois::do_all. Note that the range for this do_all call is exactly the outer loop range in the serial implementation; and that the operator is exactly the body of the outer loop in our serial implementation.

@snippet lonestar/tutorial_examples/GraphTraversalPullOperator.cpp Graph traversal in pull using do_all

The full example is available as {@link lonestar/tutorial_examples/GraphTraversalPullOperator.cpp}


@subsection galois_for_each galois::for_each

galois::for_each can be used for parallel iterations that may generate new work items, and that may have conflicts among iterations. Operators must be cautious: All locks should be acquired successfully before the first write to user state. Optional features for galois::for_each include (1) turning off conflict detection, (2) asserting that no new work items will be created, and (3) specifying desired schedule for processing active elements. galois::for_each is suitable to implement push-style algorithms.

galois::for_each uses galois::UserContext, a per-thread object, to track conflicts and new work. To insert new work items to the worklist, call galois::UserContext::push. To detect conflicts, galois::UserContext mantains a linked list of acquired items. Each sharable object, i.e. graph nodes, has a lock, which is automatically acquired when getData(), edge_begin(), edge_end(), edges(), etc. are called. Conflict is detected by Galois runtime when the lock acquisition fails. Locks are released when aborting or finishing an iteration. Since Galois assumes cautious operators, i.e. no writes to user state before acquiring all locks, there is no need to rollback user state.

galois::for_each expects the following inputs:
<ol>
<li> Range as galois::iterate, which takes one of the following parameter:
  <ul>
  <li> Pair of iterators for begin() and end()
  <li> Pair of unsigned integers for begin and end
  <li> Initializer list
  <li> Container inside which a well-defined iterator is implemented
  </ul>
<li> Operator, which can be specified as lambda expression, function object (functor) or function pointer. Using lambda expression is recommended.
<li> Options to turn on/off some features.
  <ul>
  <li> galois::loopname to turn on the collection of statistics associated with the do_all loop, e.g. execution time in milliseconds; number of iterations done, aborted and committed; etc.
  <li> galois::no_pushes when no new work items will be generated.
  <li> galois::no_conflicts to turn off conflict detection.
  <li> galois::wl to specify the schedule to use.
  </ul>
</ol>

Below is the code snippet of using galois::for_each to implement our running example using a push-style algorithm, where each node adds each of its edge's weight to the corresponding neighbor. Conflict detection is turned on in this example. Note that the operator code is written as in sequential code; and that the operator expects a reference to galois::UserContext, auto& ctx.

@snippet lonestar/tutorial_examples/GraphTraversalPushOperator.cpp For each with conflict detection

And below is the code snippet for implementing our running example using a push-style algorithm with galois::for_each or galois::do_all. Conflict detection is turned off in this example. Note that the operator code itself handles synchronization using atomic intrinsics like __sync_fetch_and_add.

@snippet lonestar/tutorial_examples/GraphTraversalPushOperator.cpp For each and do all without conflict detection

See {@link lonestar/tutorial_examples/GraphTraversalPushOperator.cpp} for the full examples.


@section galois_worklists Worklists and Schedules

So far we only addressed topology-driven algorithms, e.g. the same computation is done by all graph nodes. To implement data-driven algorithms, two more constructs are needed: (1) a worklist to track active elements, and (2) a scheduler to decide which active elements to work on first. As mentioned before, new work items can be inserted to a worklist by calling galois::UserContext::push. This section will focus on the schedulers supported by Galois.

Galois supports varieties of scheduling policies in the namespace galois::worklists. Example scheduling policies are galois::worklists::FIFO (approximate), galois::worklists::LIFO (approximate), galois::worklists::ChunkedFIFO, galois::worklists::ChunkedLIFO, galois::worklists::dChunkedFIFO, galois::worklists::dChunkedLIFO, galois::worklists::AltChunkedFIFO, galois::worklists::AltChunkedLIFO, and galois::worklists::OrderedByIntegerMetric. The default scheduler is galois::worklists::dChunkedFIFO with chunk size 32.

galois::worklists::OrderedByIntegerMetric is used to implement user-defined soft priority, a hint for Galois runtime to schedule active elements where priority inversion will not result in incorrect answers or deadlocks. It needs an indexer function to map work items to an integer (priority). Each bin corresponds to a priority level, and is itself a worklist, e.g. galois::worklists::dChunkedLIFO with chunk size 16.

Let us use single-source shortest path (SSSP) problem to illustrate the implementation of data-driven algorithms using Glois. Given (1) an edge-weighted graph G with no negative cycles, and (2) a source node s; SSSP problem asks for the shortest distance of every node n in G from s. Initially, all nodes have distances infinity from s, and s has distance 0 from itself.

Here is the operator code common to all push-style SSSP algorithms:

@snippet lonestar/tutorial_examples/SSSPPushSimple.cpp SSSP push operator

And here is code to declare worklists. Note how OBIM is constructed from an indexer, e.g. reqIndexer, and another worklist, e.g. dChunkedLIFO<16>.

@snippet lonestar/tutorial_examples/SSSPPushSimple.cpp Scheduler examples

Finally, here is the code for implementing data-driven algorithms. Initial active elements, e.g. the source node in this example, are passed to galois::iterate as an initializer list. Schedules are passed as options to galois::for_each. Note that OBIM expects an indexer instance for its construction.

@snippet lonestar/tutorial_examples/SSSPPushSimple.cpp Data-driven loops

The full example is available at {@link lonestar/tutorial_examples/SSSPPushSimple.cpp}


@subsection galois_deterministic_scheduler Deterministic Loop Iterator

galois::do_all and galois::for_each assume that the operator allows the loop iterations to be computed in any order, which may give legal yet different results non-deterministically. When it is important to have deterministic results, deterministic loop iterator can be the rescue: It executes the operator in rounds, and in each round, it deterministically chooses a conflict-free subset of currently active elements to process. In this way, Galois deterministic loop iterator can produce a same answer on different platforms, which we term it "portable determinism".

Galois' deterministic loop iterator can be launched on-demand and parameter-less by passing galois::wl< galois::worklists::Deterministic <T> > to galois::for_each. Use galois::UserContext::cautiousPoint to signal the cautious point in the operator.


@section additional_notes Additional Notes


@subsection galois_first_graph_api FirstGraph APIs

If your application requires change of graph topology, e.g. as in delaunay mesh refinement, you will need to use galois::graphs::FirstGraph. galois::graphs::FirstGraph supports all the functionalities offered by galois::graphs::LC_CSR_Graph except for size(), reporting the number of nodes in the graph; and sizeEdges(), reporting number of edges in the graph. Additionally, galois::graphs::FirstGraph provides the following APIs to modify graph topology:

<ol>
<li> galois::graphs::FirstGraph::createNode allocates space for node data, and galois::graphs::FirstGraph::addNode adds a node to a graph so the node can be found later by graph APIs.
<li> galois::graphs::FirstGraph::addEdge and galois::graphs::FirstGraph::addMultiEdge both add an edge between existing nodes to a graph. The former only adds an edge when the edge does not exist, while the latter always adds the edge.
<li> galois::graphs::FirstGraph::removeNode removes from a graph a node and edges connecting to/from the node.
<li> galois::graphs::FirstGraph::removeEdge removes from a graph an edge and its symmetric counterpart, if there is any.
</ol>

Let us use galois::graphs::FirstGraph to construct and represent a 2-dimensional torus. To define a galois::graphs::FirstGraph, you must provide as template parameters NodeTy, the type of node data; EdgeTy, the type of edge data; and a boolean value indicating whether or not this is a directed graph. The following code snippet shows an example of defining a galois::graphs::FirstGraph. See galois::graphs::FirstGraph for details about other optional template parameters.

@snippet lonestar/tutorial_examples/TorusConstruction.cpp Define a FirstGraph

And the following code snippet shows how to add nodes and edges to a galois::graphs::FirstGraph. Note that you need to create nodes first, then add the nodes to a galois::graphs::FirstGraph, and finally add edges in between the nodes.

@snippet lonestar/tutorial_examples/TorusConstruction.cpp Construct torus

See the full example at {@link lonestar/tutorial_examples/TorusConstruction.cpp}


@subsection work_in_do_all Work Distribution in galois::do_all


@subsection mem_alloc Memory Allocators

Memory allocation plays an important role in making parallel programs scalable.

@subsection tuning_guides Tuning Guides

Performance tuning is unavoidable to make a parallel program fast and scalable. Readers should keep the following points in mind when tuning:
<ol>
<li> Chunk size can be tuned to trade-off work balance and overhead to access the worklist, and may hurt priority enforcement when it is large.
<li> Schedules play an important role in performance. They trade-off the amount of wasted work and parallelism. However, there is overhead in managing additional information.
<li> NUMA-awareness in data structure and loop execution is critical for performance. galois::iterate prefers local_iterator over iterator if provided a container for this reason.
<li> Memory allocation can kill the scalability of a parallel program. Use galois::preAlloc to pre-allocate memory pages instead of allocate pages on-demand in actual loop computation.
</ol>

*/

/**
\page quickreference Quick Reference Manual

\tableofcontents

\section loops Loops and Loop Body

\subsection loop_types Loop Types

- \b Galois::for_each(I beg, I end, const F& operator, Galois::wl<WorkListType>(), Galois::loopname("loopname")

- \b Galois::do_all(I beg, I end, const F& operator, Galois::loopname("loopname")

- \b Galois::for_each_local(I beg, I end, const F& operator, Galois::wl<WorkListType>(), Galois::loopname("loopname")

- \b Galois::do_all_local(I beg, I end, const F& operator, Galois::loopname("loopname")

- \b Galois::on_each(const F& operator, Galois::loopname("loopname")



\subsection operator Operator

- \b for_each/for_each_local operator implements `template <typename C> void operator () (T item, C& ctx) {...}`

- \b do_all/do_all_local  operator implements `void operator () (T item) {...}`

- \b on_each operator implements `void operator () (unsigned TID, unsigned numThreads) {...}`

\subsection worklist WorkList Types
Specified as a template argument to {@link Galois::wl}

- Galois::WorkList::dChunkedFIFO<CHUNK_SIZE>

- Galois::WorkList::dChunkedLIFO<CHUNK_SIZE>

- Galois::WorkList::OBIM<WorkListType>

\section graph Graph


\subsection graph_api Common Graph functions

- `GNode graph.createNode(T nodeData)`:  creating a node

- `void graph.addNode(GNode gn)`: add a node created by `createNode`

- `void graph.addEdge(GNode src, GNode dst)`: add edge

- `T& graph.getData(GNode gn)`: get node data

- `Graph::iterator graph.begin()`: get a node iterator

- `Graph::iterator graph.end()`: get a node iterator

- `Graph::edge_iterator graph.edge_begin(GNode src)`: get iterator over neighbors of a node

- `Graph::edge_iterator graph.edge_end(GNode src)`: get iterator over neighbors of a node

- `E& graph.getEdgeData(Graph::edge_iterator ei)`: get edge data data

- `GNode graph.getEdgeDst(Graph::edge_iterator ei)`:  get destination node of an edge


\subsection method_flag Method Flags

{@link Galois::MethodFlag} passed optionally to graph functions

 - {@link Galois::NONE}: access to shared data is not protected. User
   responsible/aware of concurrent accesses

 - {@link Galois::CHECK_CONFLICT}: Runtime monitors access to shared data, and
   allows only one iteration to acquire ownership of the data element (e.g., node
   or edge in the graph) being accessed

 - {@link Galois::SAVE_UNDO}: Not implemented yet. Runtime monitors access to
   shared data and also records state so that it can be restored if the iteration
   aborts.

\section data_structures Other Data Structures

\section util Utility Functions
  - {@link Galois::getActiveThreads} returns number of actually running threads

  - {@link Galois::setActiveThreads} sets the number of running threads. Should only be
    called at the beginning of the `main` function.

  - {@link Galois::Runtime::LL::getMaxThreads()} returns the maximum number of
    threads (usually number of cores or number of hyper-threads) supported by hardware 

\section allocators Allocators

*/

/**
\page Manual Manual

\section parallel_loop Parallel Loops

\subsection for_each For_each
There are several choices for for_each functions:

 - {@link Galois::for_each}

This is for unordered Galois Iterators without machine topology support.  

An example to use for_each in {@link apps/tutorial/SSSPsimple.cpp} can be seen as follows:
@snippet apps/tutorial/SSSPsimple.cpp for_each in SSSPsimple

 - {@link Galois::for_each_local}

This is for unordered Galois Iterators with machine topology support. 

 - {@link Galois::for_each_ordered}
 
This is for ordered Galois Iterators. 

\subsubsection type_traits Type Traits

The functor passed to for_each may be specialized by several different type-traits to optimize the runtime with respect to the features used by the functor. See the API documentation for more details. The following is list of available type-traits.

 - needs_parallel_break

    Indicates the operator may request the parallel loop to be suspended and a given function run in serial

 - does_not_need_parallel_push

    Indicates the operator does not generate new work and push it on the worklist

 - needs_per_iter_alloc

    Indicates the operator may request the access to a per-iteration allocator

 - does_not_need_context

    Indicates the operator doesn't need a per-iteration context

 - does_not_need_stats

    Indicates the operator doesn't need its execution stats recorded 


\subsection operator Operator

An example to define an operator in {@link apps/tutorial/SSSPsimple.cpp} can be seen as follows:
@snippet apps/tutorial/SSSPsimple.cpp Operator in SSSPsimple

\subsection scheduling Scheduling Policies

The scheduling policies are listed as follows:

 - PriQueue

    implements a std::pri_queue compatible priority queue.

 - FIFO and LIFO
    
    implement std::queue and std::stack like behaviors respectively. 

 - OrderedByIntegerMetric
   
    implements a priority queue based on a supplied function which maps a work item to an integer priority. Lower values are a higher priority. An inner queue may be passed to control how items within the same priority are stored. 

 - ChunkedFIFO and ChunkedLIFO
    
    implement a chunked FIFO or LIFO strategy to reduce contention. Each thread has a chunk of work which it is filling when pushing and a chunk which is being emptied by popping. When a chunk is filled, it is placed on the central FIFO or LIFO. 

 - dChunkedFIFO and dChunkedLIFO
    
    behave like their non-d counterparts, but maintain a FIFO or LIFO per CPU package (usually L3 cache). If a processor's package local FIFO or LIFO is empty, it attempts to steal a chunk from another CPU package.

 - LocalQueues
    create local non-shared worklists which are used for all work generated during concurrent operation and use a global worklist for all initial work. 

An example to define an OrderedByIntegerMetic scheduling in {@link apps/tutorial/SSSPsimple.cpp} can be seen as follows:
@snippet apps/tutorial/SSSPsimple.cpp UpdateRequestIndexer in SSSPsimple

   The UpdateRequestIndexer defines the priority. 

@snippet apps/tutorial/SSSPsimple.cpp OrderedByIntegerMetic in SSSPsimple
   The OBIM is an example to define a priority scheduling. Internally It uses a dChunkedLIFO to store the items with the same priority.

*/
